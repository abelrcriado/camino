# Gu√≠a de Configuraci√≥n de Supabase Auth

**Proyecto**: Camino Service Backend  
**Fecha**: 17 de octubre de 2025  
**Objetivo**: Configurar autenticaci√≥n por email/password en Supabase

---

## üìã Pre-requisitos

- Acceso al dashboard de Supabase: https://supabase.com/dashboard
- Proyecto ya creado (actual: `vjmwoqwqwblllrdbnkod`)
- Tabla `usuarios` ya existente con campos: `id`, `email`, `full_name`, `phone`, `role`

---

## üîê PASO 1: Habilitar Email/Password Provider

### 1.1 Navegar a Authentication Settings

1. Abre el dashboard de Supabase: https://supabase.com/dashboard
2. Selecciona tu proyecto: **camino** (`vjmwoqwqwblllrdbnkod`)
3. En el men√∫ lateral izquierdo, clic en **Authentication** (icono de candado üîí)
4. Luego clic en **Providers** (pesta√±a superior)

### 1.2 Configurar Email Provider

**Ruta**: `Authentication > Providers > Email`

1. Busca **"Email"** en la lista de providers
2. Haz clic en el switch para **habilitar** Email authentication
3. Configuraci√≥n recomendada:

```
‚úÖ Enable Email provider
‚úÖ Confirm email (enviar email de confirmaci√≥n al registrarse)
‚¨ú Enable Email OTP (deshabilitado - usamos contrase√±a)
‚úÖ Secure email change (re-autenticaci√≥n para cambiar email)
‚úÖ Double confirm email change (doble confirmaci√≥n)
```

4. **Rate Limits** (l√≠mites anti-spam):

```
- Max sends per hour: 10 (por IP/email)
- Signup/Login attempts: 5 por minuto
```

5. Clic en **Save** (bot√≥n inferior derecho)

### 1.3 Verificar que Password Authentication est√° habilitado

Por defecto ya deber√≠a estar, pero verifica:

```
Authentication > Providers > Email > Password Configuration
‚úÖ Minimum password length: 6 characters
‚úÖ Require uppercase: No (nuestro Zod schema ya valida esto)
‚úÖ Require lowercase: No
‚úÖ Require numbers: No
‚úÖ Require special characters: No
```

> **Nota**: Nuestras validaciones Zod son M√ÅS estrictas (m√≠nimo 8 chars, may√∫scula, min√∫scula, n√∫mero) as√≠ que dejamos Supabase flexible.

---

## üìß PASO 2: Configurar Email Templates

### 2.1 Navegar a Email Templates

**Ruta**: `Authentication > Email Templates`

Aqu√≠ configurar√°s 3 plantillas de email:

### 2.2 Template: Confirm Signup (Confirmar Registro)

**Cu√°ndo se env√≠a**: Al crear cuenta nueva con `register()`

1. Selecciona **"Confirm signup"** de la lista
2. **Subject** (Asunto):

```
Confirma tu cuenta en Camino de Santiago
```

3. **Message Body** (personalizar en espa√±ol):

```html
<h2>¬°Bienvenido a Camino de Santiago!</h2>

<p>Gracias por registrarte. Para activar tu cuenta, confirma tu email haciendo clic en el bot√≥n:</p>

<p><a href="{{ .ConfirmationURL }}" style="background: #4CAF50; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block;">Confirmar Email</a></p>

<p>O copia y pega este enlace en tu navegador:</p>
<p>{{ .ConfirmationURL }}</p>

<p>Este enlace expira en 24 horas.</p>

<p>Si no creaste esta cuenta, ignora este email.</p>

<p>¬°Buen Camino! ü•æ</p>
```

4. **Redirect URL** (donde va el usuario despu√©s de confirmar):

```
http://localhost:3000/auth/verify-success
```

> **Cambiar a tu dominio en producci√≥n**: `https://camino.app/auth/verify-success`

5. Clic en **Save**

### 2.3 Template: Reset Password (Restablecer Contrase√±a)

**Cu√°ndo se env√≠a**: Al llamar `requestPasswordReset()`

1. Selecciona **"Reset password"** de la lista
2. **Subject**:

```
Restablece tu contrase√±a - Camino de Santiago
```

3. **Message Body**:

```html
<h2>Restablecer contrase√±a</h2>

<p>Recibimos una solicitud para restablecer tu contrase√±a.</p>

<p>Haz clic en el bot√≥n para crear una nueva contrase√±a:</p>

<p><a href="{{ .ConfirmationURL }}" style="background: #2196F3; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block;">Restablecer Contrase√±a</a></p>

<p>O copia y pega este enlace:</p>
<p>{{ .ConfirmationURL }}</p>

<p>Este enlace expira en 1 hora.</p>

<p><strong>Si no solicitaste esto, ignora este email.</strong> Tu contrase√±a actual sigue siendo segura.</p>
```

4. **Redirect URL**:

```
http://localhost:3000/auth/reset-password
```

> **Producci√≥n**: `https://camino.app/auth/reset-password`

5. Clic en **Save**

### 2.4 Template: Magic Link (Opcional - no usamos)

**Puedes dejarlo por defecto** - no lo usamos en nuestro sistema actual.

### 2.5 Template: Invite User (Invitar Usuario)

**Cu√°ndo se env√≠a**: Si m√°s adelante implementas invitaciones admin

Puedes configurarlo despu√©s, no es cr√≠tico ahora.

---

## ‚öôÔ∏è PASO 3: Configurar URLs y Redirects

### 3.1 Redirect URLs (Site URL)

**Ruta**: `Authentication > URL Configuration`

1. **Site URL** (URL principal de tu app):

```
Development: http://localhost:3000
Production: https://camino.app
```

2. **Redirect URLs** (permitidas para callbacks):

```
http://localhost:3000/**
http://localhost:3000/auth/**
https://camino.app/**
https://camino.app/auth/**
```

> **Importante**: El `/**` permite cualquier ruta bajo ese dominio.

3. Clic en **Save**

---

## üîë PASO 4: Configurar JWT Settings

### 4.1 Verificar configuraci√≥n JWT

**Ruta**: `Settings > API > JWT Settings`

Estos valores ya deber√≠an estar configurados, solo verifica:

1. **JWT Expiry** (duraci√≥n del access_token):

```
Default: 3600 seconds (1 hora)
Recomendado: Dejar en 3600
```

2. **Refresh Token Lifetime**:

```
Default: 2592000 seconds (30 d√≠as)
Recomendado: Dejar en 30 d√≠as
```

3. **JWT Secret** (auto-generado):

```
‚ö†Ô∏è NO CAMBIAR - se regenera autom√°ticamente
Est√° en tus variables de entorno como SUPABASE_JWT_SECRET
```

### 4.2 Verificar API Keys

**Ruta**: `Settings > API`

Verifica que tienes estas 2 keys:

1. **anon (public) key**:

```
- Usada en el frontend (React, mobile app)
- Variable: NEXT_PUBLIC_SUPABASE_ANON_KEY
- Safe to expose publicly
```

2. **service_role (private) key**:

```
- Usada en el backend (Next.js API routes)
- Variable: SUPABASE_SERVICE_ROLE_KEY
- ‚ö†Ô∏è NUNCA exponer al frontend
```

**Tu configuraci√≥n actual** (en `.env.local`):

```bash
NEXT_PUBLIC_SUPABASE_URL=https://vjmwoqwqwblllrdbnkod.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGc... (tu anon key)
SUPABASE_SERVICE_ROLE_KEY=eyJhbGc... (tu service role key)
```

---

## üóÑÔ∏è PASO 5: Configurar Trigger en tabla `usuarios`

### 5.1 Crear funci√≥n de sincronizaci√≥n

**Ruta**: `SQL Editor > New Query`

Ejecuta este SQL para crear un trigger que sincronice `auth.users` ‚Üí `usuarios`:

```sql
-- Funci√≥n para sincronizar nuevo usuario de auth a tabla usuarios
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  -- Insertar en tabla usuarios cuando se crea usuario en auth.users
  INSERT INTO public.usuarios (id, email, full_name, phone, role, created_at, updated_at)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', ''),
    COALESCE(NEW.raw_user_meta_data->>'phone', ''),
    COALESCE(NEW.raw_user_meta_data->>'role', 'user'),
    NOW(),
    NOW()
  )
  ON CONFLICT (id) DO NOTHING; -- Si ya existe, no hacer nada

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Crear trigger que ejecuta la funci√≥n
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();
```

### 5.2 Verificar que el trigger funciona

Ejecuta este query para ver triggers activos:

```sql
SELECT
  trigger_name,
  event_manipulation,
  event_object_table,
  action_statement
FROM information_schema.triggers
WHERE trigger_schema = 'auth'
  AND event_object_table = 'users';
```

Deber√≠as ver:

```
trigger_name: on_auth_user_created
event_manipulation: INSERT
event_object_table: users
action_statement: EXECUTE FUNCTION public.handle_new_user()
```

---

## ‚úÖ PASO 6: Probar la configuraci√≥n

### 6.1 Test de Registro (desde tu API)

```bash
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "TestPassword123",
    "nombre": "Usuario",
    "apellidos": "De Prueba"
  }'
```

**Verificaciones**:

1. ‚úÖ Respuesta 201 con `{ data: { user, session } }`
2. ‚úÖ Email de confirmaci√≥n enviado a `test@example.com`
3. ‚úÖ Usuario creado en tabla `usuarios` con `role: 'user'`
4. ‚úÖ Usuario creado en `auth.users` (verificar en Authentication > Users)

### 6.2 Test de Login

```bash
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "TestPassword123"
  }'
```

**Verificaci√≥n**:

1. ‚úÖ Respuesta 200 con `access_token` y `refresh_token`
2. ‚úÖ Datos del usuario desde tabla `usuarios`

### 6.3 Test de Reset Password

```bash
curl -X POST http://localhost:3000/api/auth/reset-password \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com"
  }'
```

**Verificaci√≥n**:

1. ‚úÖ Respuesta 200
2. ‚úÖ Email de reset enviado con enlace

### 6.4 Verificar en Dashboard

**Ruta**: `Authentication > Users`

Deber√≠as ver:

- ‚úÖ Usuario `test@example.com`
- ‚úÖ Estado: `Confirmed` (si confirm√≥ email) o `Unconfirmed`
- ‚úÖ `Last Sign In`: timestamp del login
- ‚úÖ `Created At`: timestamp de registro

---

## üîí PASO 7: Configurar Row Level Security (RLS)

### 7.1 Habilitar RLS en tabla usuarios

**Ruta**: `Table Editor > usuarios > RLS Policies`

1. Clic en **"Enable RLS"** (bot√≥n superior derecho)

### 7.2 Crear pol√≠ticas de seguridad

Ejecuta en **SQL Editor**:

```sql
-- Pol√≠tica: Los usuarios solo pueden ver su propio perfil
CREATE POLICY "Users can view own profile"
ON public.usuarios
FOR SELECT
TO authenticated
USING (auth.uid() = id);

-- Pol√≠tica: Los usuarios solo pueden actualizar su propio perfil
CREATE POLICY "Users can update own profile"
ON public.usuarios
FOR UPDATE
TO authenticated
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

-- Pol√≠tica: Solo service_role puede insertar (registro desde backend)
CREATE POLICY "Service role can insert users"
ON public.usuarios
FOR INSERT
TO service_role
WITH CHECK (true);

-- Pol√≠tica: Admins pueden ver todos los usuarios
CREATE POLICY "Admins can view all users"
ON public.usuarios
FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM public.usuarios
    WHERE id = auth.uid() AND role = 'admin'
  )
);
```

### 7.3 Verificar pol√≠ticas activas

```sql
SELECT
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd
FROM pg_policies
WHERE tablename = 'usuarios';
```

---

## üì± PASO 8: Configurar Email Provider (SMTP opcional)

### Opci√≥n A: Usar Supabase Email (Desarrollo)

**Por defecto ya activo** - Supabase env√≠a emails desde `noreply@mail.app.supabase.io`

**Limitaciones**:

- ‚ö†Ô∏è M√°ximo 3-4 emails/hora en plan gratuito
- ‚ö†Ô∏è Puede caer en spam
- ‚úÖ Perfecto para desarrollo

### Opci√≥n B: Configurar SMTP Custom (Producci√≥n)

**Ruta**: `Settings > Auth > SMTP Settings`

**Providers recomendados**:

1. **SendGrid** (12,000 emails/mes gratis)
2. **Mailgun** (5,000 emails/mes gratis)
3. **Resend** (3,000 emails/mes gratis)

**Configuraci√≥n ejemplo (SendGrid)**:

```
SMTP Host: smtp.sendgrid.net
SMTP Port: 587
SMTP Username: apikey
SMTP Password: <tu-sendgrid-api-key>
Sender Email: noreply@camino.app
Sender Name: Camino de Santiago
```

---

## ‚úÖ Checklist Final de Verificaci√≥n

Antes de dar por completada la configuraci√≥n:

- [ ] **Email Provider habilitado** (Authentication > Providers > Email)
- [ ] **Email de confirmaci√≥n activado** (Confirm email = ON)
- [ ] **Templates en espa√±ol configurados** (Confirm signup, Reset password)
- [ ] **Redirect URLs configuradas** (localhost + producci√≥n)
- [ ] **JWT settings verificados** (1h access, 30d refresh)
- [ ] **API Keys copiadas a .env.local** (ANON_KEY + SERVICE_ROLE_KEY)
- [ ] **Trigger `on_auth_user_created` activo** (sincroniza auth ‚Üí usuarios)
- [ ] **RLS habilitado en tabla usuarios** (4 pol√≠ticas activas)
- [ ] **Test de registro exitoso** (email enviado + usuario creado)
- [ ] **Test de login exitoso** (tokens generados)
- [ ] **Test de reset password exitoso** (email recibido)
- [ ] **Usuario visible en dashboard** (Authentication > Users)

---

## üêõ Troubleshooting Com√∫n

### Problema 1: "Email not confirmed"

**Causa**: Usuario registrado pero no confirm√≥ email

**Soluci√≥n**:

```sql
-- Confirmar manualmente en desarrollo
UPDATE auth.users
SET email_confirmed_at = NOW()
WHERE email = 'test@example.com';
```

### Problema 2: "No se env√≠an emails"

**Verificar**:

1. `Authentication > Providers > Email` est√° habilitado
2. `Email Templates` est√°n guardadas
3. Rate limits no excedidos (max 10/hora en dev)
4. Revisar `Authentication > Logs` para errores

### Problema 3: "Usuario en auth.users pero no en tabla usuarios"

**Causa**: Trigger no ejecutado

**Verificar**:

```sql
-- Ver si trigger existe
SELECT * FROM information_schema.triggers
WHERE trigger_name = 'on_auth_user_created';

-- Insertar manualmente si falta
INSERT INTO usuarios (id, email, full_name, role)
SELECT id, email,
       raw_user_meta_data->>'full_name',
       COALESCE(raw_user_meta_data->>'role', 'user')
FROM auth.users
WHERE id NOT IN (SELECT id FROM usuarios);
```

### Problema 4: "Invalid JWT token"

**Causa**: Token expirado o service_role_key incorrecta

**Verificar**:

```bash
# Revisar env vars
echo $SUPABASE_SERVICE_ROLE_KEY

# Comparar con dashboard: Settings > API > service_role key
```

---

## üìö Documentaci√≥n Supabase

- [Auth Guide](https://supabase.com/docs/guides/auth)
- [Email Auth](https://supabase.com/docs/guides/auth/auth-email)
- [Server-side Auth](https://supabase.com/docs/guides/auth/server-side-rendering)
- [Row Level Security](https://supabase.com/docs/guides/auth/row-level-security)

---

## üéâ ¬°Configuraci√≥n Completa!

Tu sistema de autenticaci√≥n est√° listo para:

- ‚úÖ Registro de usuarios con confirmaci√≥n por email
- ‚úÖ Login con email/password
- ‚úÖ Recuperaci√≥n de contrase√±a
- ‚úÖ Refresh de tokens autom√°tico
- ‚úÖ Protecci√≥n de rutas con middleware
- ‚úÖ Row Level Security en base de datos

**Siguiente paso**: Probar todos los endpoints desde Postman o el frontend.
